# formatted by maomi-i18n-format

[translation]
"maomi" = "maomi"
"Introduction" = "介绍"
"Guide" = "入门"
"Documents" = "文档"
"GitHub" = "GitHub"
" | " = " | "
"crates.io" = "crates.io"
"lastleaf.me" = "lastleaf.me"
"This website is powered by maomi. " = "这个网站基于 maomi 开发。"
"Source code is here." = "看看源代码吧。"
"Not Found" = "页面未找到"
"< " = "< "
" >" = " >"

[index]
"maomi" = "maomi"
"Strict and Performant Web Application Programming" = "严谨、高性能 Web 应用编程"
"Programming in Rust" = "使用 rust 语言开发"
"Write rust code, compile to WebAssembly, and run in browser." = "编写 rust 代码、编译到 WebAssembly 、在浏览器中运行。"
"Better Performance" = "性能更优"
"Maomi is optimized for speed. The performance is even better than hand-written JavaScript without any framework." = "maomi 针对运行速度进行优化。性能甚至优于未使用框架的手写 JavaScript 代码。"
"overall timing (geometry mean)" = "总体耗时（各测试项的几何平均）"
"large tree build timing" = "大节点树创建耗时"
"This DOM manipulation benchmark is based on " = "这项 DOM 操作性能测试基于 "
"js-framework-benchmark" = "js-framework-benchmark"
"Report Mistakes while Compilation" = "在编译期提示错误信息"
"Like rust, maomi reports mistakes while compilation. The mistakes include wrong element names, invalid properties, and even wrong style class names." = "类似于 rust 本身， maomi 在编译期提示代码错误。这些错误包括标签名错误、属性错误，甚至错误的样式 class 名。"
"Work with rust-analyzer in IDE" = "通过 rust-analyzer 在 IDE 中提示错误"
"With rust-analyzer installed, it is much easier to investigate elements, properties, and even style classes." = "如果安装了 rust-analyzer ，可以简单地跳转到组件标签、属性甚至样式 class 定义。"
"Data Bindings" = "数据绑定"
"Maomi is based on templates and data bindings." = "maomi 基于模板和数据绑定编程。"
"Limited CSS" = "约束性 CSS"
"Maomi supports a limited stylesheet syntax. It restricts the usage of CSS to make the styling easier to investigate." = "maomi 支持一种特殊的样式表语法。它限制 CSS 的灵活性，使得样式表更容易维护。"
"High Performance Server Side Rendering" = "高性能服务器端渲染"
"Maomi supports server side rendering. It just execute native rust binary in the server to generate HTML output. It is much more performant than using a JavaScript runtime." = "maomi 支持服务器端渲染。它直接在服务器上运行原生 rust 二进制来生成 HTML 。这使得它比普通 JavaScript 代码高效得多。"
"Integrated i18n Support" = "内置 i18n 国际化支持"
"Maomi supports i18n in the core design. It is easy to compile with TOML-based translation files to generate different version of the application." = "maomi 在核心设计时就考虑了国际化支持。可以简单地使用 TOML 格式的翻译文件来生成不同语言版本的编译结果。"
"declare a component" = "定义组件"
"write a template" = "添加组件模板"
"implement Component trait" = "实现 Component trait"
"write styles" = "添加样式"
"use struct fields in the template" = "在模板上使用 struct 字段"
"maomi - Strict and Performant Web Application Programming" = "maomi - 严谨、高性能 Web 应用编程"

[guide]
"Add dependencies in Cargo.toml" = "在 Cargo.toml 中添加依赖"
"To use maomi, rust 1.65+ is required. Then add maomi as cargo dependencies. In Cargo.toml:" = "maomi 依赖 rust 1.65 或更高版本。在 Cargo.toml 中添加 maomi 依赖项："
"In real world, some other crates are also needed:" = "在实际环境中，还需要一些其他 crate ："
"#[component] struct" = "#[component] struct 结构"
"A page is composed by components. To generate a page with maomi, write a component first." = "页面由组件构成。要使用 maomi 生成页面，首先应编写一个组件。"
"A component is a struct with \"#[component]\" attribute:" = "组件是一个标有 #[component] 的结构："
"The struct must contain a \"template!\" field. It contains the template of this component." = "struct 中必须包含一个 template! 字段，用于包含这个组件的模板。"
"Implement Component trait" = "实现 Component trait"
"The \"Component\" trait should be implemented for the component struct:" = "组件必须实现 Component trait ："
"Render the Component into page body" = "将组件放入页面主体"
"Finally, this component can be put into the page body." = "这样，组件就可以放入页面主体中。"
"Compile to WebAssembly" = "编译到 WebAssembly"
"Compile the code with " = "编译代码时使用"
"wasm-pack" = "wasm-pack"
"The generated code is under the \"pkg\" directory." = "生成的代码位于 pkg 目录中。"
"Write an HTML wrapper" = "编写 HTML 文件"
"Write an HTML file with empty <body>." = "编写一个 HTML 文件，将 <body> 留空。"
"Then serve it in an HTTP server and see the result!" = "然后启动一个 HTTP 服务器并访问这个文件，看看结果吧！"
"enable console log" = "激活 console 日志"
"initialize a backend context in HTML <body>" = "在 HTML <body> 内初始化一个 backend 环境"
"create a mount point for the component" = "创建一个挂载点用于放置组件"
"leak the mount point and the backend context to keep working forever" = "将挂载点和 backend 环境泄露掉、使它们不在函数结束时回收，这样就可以一直运行"
"{} - {}" = "{} - {}"
"maomi Guide" = "maomi 介绍"
"Write a Component" = "编写一个组件"
"Quoted text" = "用双引号包裹文本"
"The template looks like HTML or XML, but the text content must be quoted!" = "模板看起来和 HTML 或 XML 差不多，但文本内容必须使用双引号包裹！"
"Comments" = "注释"
"Note that comments are rust-style (not XML style)." = "注意，注释是类似 rust 的（与 XML 风格不同）。"
"End tags and self-close tags" = "结束标签和自闭合标签"
"The end tag can be replaced by \"</_>\" for short." = "结束标签可以使用 </_> 来简化。"
"Self-close tags (like XML) are also supported." = "自闭合标签（类似于 XML ）也是支持的。"
"Dynamic text content" = "动态文本内容"
"It is able to use an expression as the text content. Use a brace \"{}\" to embed an expression." = "可以使用表达式来表示动态文本内容。使用 {} 来嵌入一个表达式。"
"It is able to use the \"self\" reference in the expression." = "在表达式中可以使用 self 引用。"
"Be careful: when using fields in \"self\", do not move out the fields." = "请注意：当使用 self 时，不能移出其中的字段。"
"Attributes" = "标签属性"
"It is able to use attributes (like XML), but non-string values should not be quoted." = "可以使用标签属性（类似于 XML ），但非字符串值不能用双引号包裹。"
"The \"=true\" can be omitted." = "属性值是 =true 时可以省略。"
"Attributes also support expressions. Note that the attributes are typed." = "标签值也可以使用表达式。注意它是有类型的。"
"String attributes can only be assigned string values. Boolean attributes can only be assigned boolean values." = "字符串类型的属性只接受字符串值，布尔属性只接受布尔值。"
"Expressions for attributes always accept references." = "使用表达式作为值时，表达式值必须是引用。"
"The \"&\" can be written outside the brace - sometimes it looks better." = "引用标记 & 可以写在花括号外面——这样写有时候会更直观。"
"error: text content must be quoted" = "错误：文本内容必须使用双引号包裹"
"correct:" = "正确："
"Template Nodes" = "模板节点"
# "If statements" = ""
# "The if statements are allowed." = ""
# "Likewise, the if-let statements are also allowed." = ""
# "Match statements" = ""
# "The match statements are just like common rust code." = ""
# "Template Branches" = ""
# "For statements" = ""
# "The for statements are allowed." = ""
# "For statements with keys" = ""
# "If the list often changes, it's better to specify a key for the list." = ""
# "The key should be an unique identifier for each item. It is used to identify how the list changes and make list changes faster." = ""
# "To specify a key, the list structure must implement \"AsListKey\"." = ""
# "If the for statement generates more than one variable, it is required to specify which variable is used as the key." = ""
# "Template Repeats" = ""
# "Template Updates" = ""
# "Maomi is based on data bindings. Changing the component fields will auto-update the template." = ""
# "However, changes to the component fields should always be asynchronous. To visit the component fields, a task must be generated." = ""
# "About Tasks" = ""
# "Tasks are asynchronous jobs that can visit one component." = ""
# "To generate a task, call task on the ref-counted token. In this way, the template will always be updated after the task ends." = ""
# "Sometimes it is needed to read fields but not update them. To avoid the template update overhead, it is able to generate a read-or-write task." = ""
# "Because tasks are asynchronous, references cannot move across tasks. Thus &self is not usable in tasks. The ref-counted token can be cloned and move across tasks." = ""
# "this function is executed after the component creation" = ""
# "acquire a ref-counted token of the component" = ""
# "generate a task" = ""
# "the template will be updated after the task ends" = ""
# "the template will be not be updated" = ""
# "unless need_update is called" = ""
# "Event bindings" = ""
# "It is able to bind an event listener function to DOM events." = ""
# "Custom Event Arguments" = ""
# "When binding listeners, extra arguments can be added." = ""
# "Only references can be used as arguments (and the data type should implement `Clone` or `ToOwned` trait)." = ""
# "Tap events" = ""
# "To be mobile friendly, maomi provides tap events as a combination of mouse events and touch events." = ""
# "Long tap events are also supported." = ""
# "avoid further tap event" = ""
# "Events" = ""
# "Define style classes" = ""
# "Maomi supports a limited form of CSS." = ""
# "In most cases, styles should be specified through classes." = ""
# "Like common rust structs, classes can be public and used by multiple components." = ""
# "The class name is in the same namespace of the rust structs and enums." = ""
# "Do not use element tag name as class names, otherwise the element tag name cannot be used." = ""
# "Property syntax" = ""
# "The stylesheet syntax is different from standard CSS." = ""
# "The basic property syntax is \"xxx = xxx;\", and the CSS words should be connected with \"_\"." = ""
# "Numbers with units should be written as follows:" = ""
# "Colors in \"#xxx\" forms should be written as follows:" = ""
# "Debug the CSS output" = ""
# "When not sure about the CSS output, add a \"#[error_css_output]\" before the class and the generated CSS will output as an error message." = ""
# "Hashed class names" = ""
# "The class names are properly hashed. It is totally OK to use the same class name in different modules." = ""
# "It is OK to specified the hashed name." = ""
# "Generated CSS output" = ""
# "Maomi will generate a static CSS file for each crate." = ""
# "To get the output CSS file, specify the output path in Cargo.toml." = ""
# "If \"css-out-mode\" is configured to \"debug\", the generated CSS will be easier to read." = ""
# "The CSS output is in the specified \"css-out-dir\". Generated file name is \"[CRATE_NAME].css\". Use it in HTML head:" = ""
# "This two options can be override by environment variables \"MAOMI_CSS_OUT_DIR\" and \"MAOMI_CSS_OUT_MODE\"." = ""
# "error: do not use \"div\" as class name" = ""
# "use \"=\" instead of \":\", and \";\" is always required" = ""
# "use \"_\" instead of \"-\"" = ""
# "this generates \"font-size: 1.5em;\"" = ""
# "this generates \"padding: 1px 0.1rem;\"" = ""
# "this generates \"background-color: #00d2ff;\"" = ""
# "Style Classes" = ""
# "Media Queries" = ""
# "Unlike standard CSS, media queries should be inside classes." = ""
# "Feature detection with \"@supports\" likewise." = ""
# "Pseudo classes" = ""
# "Pseudo classes should also be inside classes." = ""
# "Conditional Styles" = ""
# "Constant value" = ""
# "It is able to define constants in stylesheets." = ""
# "The constant can be any CSS token, but should only be a single token." = ""
# "Keyframes definition" = ""
# "Keyframes can be declared as a special type of constants." = ""
# "cannot be multiple tokens" = ""
# "Style Constants" = ""
# "Functions with arguments" = ""
# "To reuse similar properties in different classes, functions can be used." = ""
# "Functions can take arguments, but the arguments can only be numbers (as \"f32\") or strings (as \"&str\")" = ""
# "Number arguments can be used in unit-values." = ""
# "String arguments can be used in colors." = ""
# "Dynamic Styling" = ""
# "Besides classes, a special kind of functions can also be used in templates." = ""
# "This kind of functions should contain exactly one argument, and declared with \"style\" instead of \"fn\"." = ""
# "This can be used when some property values should be dynamically calculated." = ""
# "Style Functions" = ""
# "Global stylesheet usage" = ""
# "Some constants may be used in several stylesheets in the whole crate. It is able to write them in a global stylesheet." = ""
# "The default global stylesheet is located at \"src/lib.mcss\". This path can be changed by \"stylesheet-mod-root\" in Cargo.toml." = ""
# "Constants can be declared inside this file." = ""
# "Stylesheets can use the global constants with a \"use\" statement." = ""
# "Normal functions (not dynamic style functions) can also be declared." = ""
# "Then in stylesheets:" = ""
# "Submodules in global stylesheets" = ""
# "If the global stylesheet is large, the \"mod\" statement can be used to split it into several files." = ""
# "In \"src/my_sub.mcss\":" = ""
# "Global Stylesheets" = ""
# "Using component in component" = ""
# "Components in maomi are low-cost abstractions. Some web frameworks have a significant overhead with components, but maomi only has a little. Sometimes components can help improve performance." = ""
# "Like DOM elements, a component can be used as tags." = ""
# "Slots in components" = ""
# "The component can put a \"<slot />\" tag in the template. It will be replaced with the child nodes in its users." = ""
# "It is able to pass data in the slot with \"data\" attribute. Its users can retrieve the reference of the data with \"slot:xxx\" attributes." = ""
# "Besides it, the slot data type should be specified with the \"SlotData\" attribute argument." = ""
# "Using Components" = ""
# "Using events in components" = ""
# "Components can trigger events to its users." = ""
# "An event can contain a piece of data `T` , wrapped as `Event<T>` . The event data should be provided when triggering it." = ""
# "Note that the event fields should be properly \"pub\" so that it can be assigned from templates in other rust modules." = ""
# "Component Events" = ""
# "Using properties in components" = ""
# "Components can contain several fields which are assignable through template attributes." = ""
# "The properties should be wrapped with \"Prop\". The \"Prop\" type implements \"Deref\" so it can be dereferenced to the contained type." = ""
# "Note that the property fields should be properly \"pub\" so that it can be assigned from templates in other rust modules." = ""
# "Two-way properties" = ""
# "Common properties are one-way: the component receives the value from its user." = ""
# "Sometimes it is required to be two-way, e.g. synchronize input values between components." = ""
# "In these cases, \"BindingProp\" and \"BindingValue\" can be used. However, the changes of two-way values do not automatically triggering the template update. A task should be manually generated if the template update is required." = ""
# "Note that \"BindingProp\" and \"BindingValue\" do not implement \"Deref\" - use explicit getter functions to retrieve the value." = ""
# "Properties" = ""
# "How server side rendering works" = ""
# "Normally, maomi generates HTML elements in browsers. At startup, it takes an empty DOM node, a.k.a. a mount-point, and then repeatedly insert or modify other nodes." = ""
# "The server side rendering can generate static HTML segments in the server. The HTML segment can be inserted into the mount-point before startup. Then maomi will reuse the generated HTML nodes at startup." = ""
# "This allows static contents embed in HTML directly, and be understood by search engines better." = ""
# "Because maomi is in rust, the component code can be compiled to native binary which can be used to generate HTML segments. It means the components are compiled twice: one is to the native binary which is used to generate the static HTML, the other is to the WebAssembly binary which is used in browser runtime." = ""
# "To enable server side rendering, some features need to be specified in Cargo.toml. The \"prerendering\" feature is to enable the server side support, and the \"prerendering-apply\" feature is to enable the reuse of the server side generated nodes." = ""
# "Note that these features slightly increase the runtime overhead. Do not enable them if server side rendering is not needed." = ""
# "Prerenderable Components" = ""
# "To be rendered in server side, the component must implement \"PrerenderableComponent\". This trait has two associated types and two functions." = ""
# "The \"QueryData\" type refers to the query, e.g. the URL params, the POST data, or some other related data. For static contents, it can simply be \"()\"." = ""
# "The \"PrerenderingData\" type is converted from the \"QueryData\", containing some useful parts of the query for the component startup. It should be serializable and transferable from server side to the client side." = ""
# "When doing server side rendering, firstly, the \"prerendering_data\" function is called in server side to convert \"QueryData\" to \"PrerenderingData\". (It may also be called in client side when doing client side rendering.)" = ""
# "Secondly, the component starts in the server side, and the \"apply_prerendering_data\" is called. This function can modify component fields according to the \"PrerenderingData\". The HTML segment can be generated when the component created." = ""
# "Thirdly, the generated HTML should be embed into the mount-point, and the \"PrerenderingData\" should also be transferred to the client side." = ""
# "Fourthly, the component starts in the client side, and the \"apply_prerendering_data\" is also called. This function must do the same thing as it did in the server side. Thus this component can reuse the generated HTML nodes." = ""
# "Generate HTML in server side" = ""
# "To generate HTML in server side, a special kind of backend context is used." = ""
# "Reuse the generated HTML in client side" = ""
# "To reuse the generated HTML in server side, the backend context should be initialized in with \"PrerenderingData\"." = ""
# "generate the `PrerenderingData`" = ""
# "serialize the `PrerenderingData` to transfer to the client side" = ""
# "initialize a backend context for HTML generation" = ""
# "generate HTML segment" = ""
# "returns the HTML and the `PrerenderingData`" = ""
# "the HTML should finally be placed in the HTML <body />" = ""
# "the `PrerenderingData` can be base64 embed to HTML or transfer in other forms" = ""
# "deserialize the `PrerenderingData`" = ""
# "construct the `PrerenderingData`" = ""
# "initialize a backend context for reuse generated HTML" = ""
# "create the mount point" = ""
# "Server Side Rendering" = ""
# "Enable i18n support" = ""
# "Maomi can generate different binaries for different languages, a.k.a. the i18n support." = ""
# "By default, i18n support is disable. To enable it, specify the locale in \"MAOMI_I18N_LOCALE\" environment variable while compilation." = ""
# "When this environment variable often changes, it is recommended to add this line to build.rs:" = ""
# "Translation files" = ""
# "When i18n support enabled, maomi requires every text node in the template to be translated." = ""
# "Every string without translation will be marked a compilation error." = ""
# "To translate this string, create a \"i18n/[LOCALE].toml\" file. Use \"i18n/zh_CN.toml\" as an example:" = ""
# "The string will be replaced according to this file when compiling the \"MAOMI_I18N_LOCALE=zh_CN\" version." = ""
# "Dynamic string translation" = ""
# "If the text node is an expression, the value must be a \"LocaleString\" or \"LocaleStaticStr\". Normal strings are not accepted." = ""
# "If the string is static and can be translated through translation files, the `i18n!` macro can be used to translate it." = ""
# "If the string is dynamic content or does not need to be translated, mark it as translated manually." = ""
# "Translation groups" = ""
# "By default, the \"[translation]\" group in translation files are used. It is able to use other groups." = ""
# "Then in the translation file:" = ""
# "For dynamic string translation, use \"i18n_group!\" to get the group." = ""
# "Format tools for translation files" = ""
# "The \"maomi-tools\" crate provides a tool \"maomi-i18n-format\" to collect untranslated strings and format the translation files." = ""
# "Collect the metadata with \"MAOMI_I18N_LOCALE\" and \"MAOMI_I18N_FORMAT_METADATA\" environment variable." = ""
# "Then do the format:" = ""
# "I18n Support" = ""
# "About execution speed" = ""
# "Maomi is greatly optimized on execution speed. In most cases, there is no need to worry about it." = ""
# "On the other hand, most high-level code does not need to be so fast. Don't be afraid to write simple code that is a little slower." = ""
# "If there is a need of profiling, note that the release builds are much faster then debug builds (like most rust programs do)." = ""
# "About code size" = ""
# "In most cases, WebAssembly binary is bigger than JavaScript code, but it generally has a better compression rate. Do not forget to turn on HTTP compression on the generated binary." = ""
# "Besides that, some code generation options have great helps to reduce the generated WebAssembly binary size. It is recommended to use the following options in Cargo.toml." = ""
# "Runtime Performance Tips" = ""
# "About compilation time" = ""
# "Maomi requires a lot of compile-time optimizations, so the compilation time might be really long in old machines." = ""
# "To improve the compilation speed, the best way is to split components into several small crates, since rust compilation is crate-by-crate. If a crate code is not changed, it will not be re-compiled." = ""
# "Another important tip is to avoid server side rendering compilation while debugging component logic. Since when server side rendering requires native binary for each components, this doubles the compilation time." = ""
# "In general, smaller components bring more code re-using and compile faster. In maomi, components are near zero-cost abstractions which has very low runtime overhead." = ""
# "About working with IDE" = ""
# "When editing code in IDE with rust-analyzer, large code may slow down rust-analyzer, bringing bad coding experience." = ""
# "It is able to tell maomi to optimize for rust-analyzer. When working with rust-analyzer, maomi can try to generate faster results. The results is not runnable but fast in cargo check." = ""
# "To enable this feature, set environment variable MAOMI_RUST_ANALYZER=on to rust-analyzer. Use Visual Studio Code as the example, this environment variable can be set in \"rust-analyzer.cargo.extraEnv\" settings." = ""
# "Compilation Performance Tips" = ""
# "Basics" = ""
# "Template Semantics" = ""
# "Stylesheets" = ""
# "Components" = ""
# "Advanced Features" = ""
# "Performance Tips" = ""
