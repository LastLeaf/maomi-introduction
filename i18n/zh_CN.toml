# formatted by maomi-i18n-format

[translation]
"maomi" = "maomi"
"Introduction" = "介绍"
"Guide" = "入门"
"Documents" = "文档"
"GitHub" = "GitHub"
" | " = " | "
"crates.io" = "crates.io"
"lastleaf.me" = "lastleaf.me"
"This website is powered by maomi. " = "这个网站基于 maomi 开发。"
"Source code is here." = "看看源代码吧。"
"Not Found" = "页面未找到"
"< " = "< "
" >" = " >"

[index]
"maomi" = "maomi"
"Strict and Performant Web Application Programming" = "严谨、高性能 Web 应用编程"
"Programming in Rust" = "使用 rust 语言开发"
"Write rust code, compile to WebAssembly, and run in browser." = "编写 rust 代码、编译到 WebAssembly 、在浏览器中运行。"
"Better Performance" = "性能更优"
"Maomi has great overall performance and avoids common performance pitfalls. Like rust language itself, there is no worry about performance in maomi application programming." = "maomi 有很好的全局性能，避免了常见性能陷阱。如同 rust 语言本身，在编写 maomi 应用时无需担心性能。"
"tree build timing" = "节点树创建耗时"
"tree update timing" = "节点树更新耗时"
"component abstraction timing" = "组件抽象耗时"
"This DOM manipulation benchmark is based on " = "这项 DOM 操作性能测试基于 "
"js-framework-benchmark" = "js-framework-benchmark"
"Report Mistakes while Compilation" = "在编译期提示错误信息"
"Like rust, maomi reports mistakes while compilation. The mistakes include wrong element names, invalid properties, and even wrong style class names." = "类似于 rust 本身， maomi 在编译期提示代码错误。这些错误包括标签名错误、属性错误，甚至错误的样式 class 名。"
"Work with rust-analyzer in IDE" = "通过 rust-analyzer 在 IDE 中提示错误"
"With rust-analyzer installed, it is much easier to investigate elements, properties, and even style classes." = "如果安装了 rust-analyzer ，可以简单地跳转到组件标签、属性甚至样式 class 定义。"
"Data Bindings" = "数据绑定"
"Maomi is based on templates and data bindings." = "maomi 基于模板和数据绑定编程。"
"Limited CSS" = "约束性 CSS"
"Maomi supports a limited stylesheet syntax. It restricts the usage of CSS to make the styling easier to investigate." = "maomi 支持一种特殊的样式表语法。它限制 CSS 的灵活性，使得样式表更容易维护。"
"High Performance Server Side Rendering" = "高性能服务器端渲染"
"Maomi supports server side rendering. It just execute native rust binary in the server to generate HTML output. It is much more performant than using a JavaScript runtime." = "maomi 支持服务器端渲染。它直接在服务器上运行原生 rust 二进制来生成 HTML 。这使得它比普通 JavaScript 代码高效得多。"
"Integrated i18n Support" = "内置 i18n 国际化支持"
"Maomi supports i18n in the core design. It is easy to compile with TOML-based translation files to generate different version of the application." = "maomi 在核心设计时就考虑了国际化支持。可以简单地使用 TOML 格式的翻译文件来生成不同语言版本的编译结果。"
"declare a component" = "定义组件"
"write a template" = "添加组件模板"
"implement Component trait" = "实现 Component trait"
"write styles" = "添加样式"
"use struct fields in the template" = "在模板上使用 struct 字段"
"maomi - Strict and Performant Web Application Programming" = "maomi - 严谨、高性能 Web 应用编程"

[guide]
"Add dependencies in Cargo.toml" = "在 Cargo.toml 中添加依赖"
"To use maomi, rust 1.65+ is required. Then add maomi as cargo dependencies. In Cargo.toml:" = "maomi 依赖 rust 1.65 或更高版本。在 Cargo.toml 中添加 maomi 依赖项："
"In real world, some other crates are also needed:" = "在实际环境中，还需要一些其他 crate ："
"#[component] struct" = "#[component] struct 结构"
"A page is composed by components. To generate a page with maomi, write a component first." = "页面由组件构成。要使用 maomi 生成页面，首先应编写一个组件。"
"A component is a struct with \"#[component]\" attribute:" = "组件是一个标有 #[component] 的结构："
"The struct must contain a \"template!\" field. It contains the template of this component." = "struct 中必须包含一个 template! 字段，用于包含这个组件的模板。"
"Implement Component trait" = "实现 Component trait"
"The \"Component\" trait should be implemented for the component struct:" = "组件必须实现 Component trait ："
"Render the Component into page body" = "将组件放入页面主体"
"Finally, this component can be put into the page body." = "这样，组件就可以放入页面主体中。"
"Compile to WebAssembly" = "编译到 WebAssembly"
"Compile the code with " = "编译代码时使用 "
"wasm-pack" = "wasm-pack"
"The generated code is under the \"pkg\" directory." = "生成的代码位于 pkg 目录中。"
"Write an HTML wrapper" = "编写 HTML 文件"
"Write an HTML file with empty <body>." = "编写一个 HTML 文件，将 <body> 留空。"
"Then serve it in an HTTP server and see the result!" = "然后启动一个 HTTP 服务器并访问这个文件，看看结果吧！"
"enable console log" = "激活 console 日志"
"initialize a backend context in HTML <body>" = "在 HTML <body> 内初始化一个 backend 环境"
"create a mount point for the component" = "创建一个挂载点用于放置组件"
"leak the mount point and the backend context to keep working forever" = "将挂载点和 backend 环境泄露掉、使它们不在函数结束时回收，这样就可以一直运行"
"{} - {}" = "{} - {}"
"maomi Guide" = "maomi 介绍"
"Write a Component" = "编写一个组件"
"Quoted text" = "用双引号包裹文本"
"The template looks like HTML or XML, but the text content must be quoted!" = "模板看起来和 HTML 或 XML 差不多，但文本内容必须使用双引号包裹！"
"Comments" = "注释"
"Note that comments are rust-style (not XML style)." = "注意，注释是类似 rust 的（与 XML 风格不同）。"
"End tags and self-close tags" = "结束标签和自闭合标签"
"The end tag can be replaced by \"</_>\" for short." = "结束标签可以使用 </_> 来简化。"
"Self-close tags (like XML) are also supported." = "自闭合标签（类似于 XML ）也是支持的。"
"Dynamic text content" = "动态文本内容"
"It is able to use an expression as the text content. Use a brace \"{}\" to embed an expression." = "可以使用表达式来表示动态文本内容。使用 {} 来嵌入一个表达式。"
"It is able to use the \"self\" reference in the expression." = "在表达式中可以使用 self 引用。"
"Be careful: when using fields in \"self\", do not move out the fields." = "请注意：当使用 self 时，不能移出其中的字段。"
"Attributes" = "标签属性"
"It is able to use attributes (like XML), but non-string values should not be quoted." = "可以使用标签属性（类似于 XML ），但非字符串值不能用双引号包裹。"
"The \"=true\" can be omitted." = "属性值是 =true 时可以省略。"
"Attributes also support expressions. Note that the attributes are typed." = "标签值也可以使用表达式。注意它是有类型的。"
"String attributes can only be assigned string values. Boolean attributes can only be assigned boolean values." = "字符串类型的属性只接受字符串值，布尔属性只接受布尔值。"
"Expressions for attributes always accept references." = "使用表达式作为值时，表达式值必须是引用。"
"The \"&\" can be written outside the brace - sometimes it looks better." = "引用标记 & 可以写在花括号外面——这样写有时候会更直观。"
"error: text content must be quoted" = "错误：文本内容必须使用双引号包裹"
"correct:" = "正确："
"Template Nodes" = "模板节点"
"If statements" = "if 语句"
"The if statements are allowed." = "可以使用 if 语句。"
"Likewise, the if-let statements are also allowed." = "类似地，也可以用 if-let 语句。"
"Match statements" = "match 语句"
"The match statements are just like common rust code." = "match 语句的用法就像普通 rust 代码一样。"
"Template Branches" = "模板分支"
"For statements" = "for 语句"
"The for statements are allowed." = "可以使用 for 语句。"
"For statements with keys" = "含有 key 的 for 语句"
"If the list often changes, it's better to specify a key for the list." = "如果列表经常变化，最好为列表指定一个 key 。"
"The key should be an unique identifier for each item. It is used to identify how the list changes and make list changes faster." = "key 须为每一项的唯一标识，它用来检测各个项目之间是怎样变化的，从而使列表变更更加高效。"
"To specify a key, the list structure must implement \"AsListKey\"." = "在指定 key 时，列表数据结构必须实现 AsListKey 。"
"If the for statement generates more than one variable, it is required to specify which variable is used as the key." = "如果 for 语句引入了超过一个变量，必须指定哪个变量被用作 key 。"
"Template Repeats" = "模板列表"
"Template updates" = "模板更新"
"Maomi is based on data bindings. Changing the component fields will auto-update the template." = "maomi 基于数据绑定。通过改变组件数据字段就可以更新组件的模板中内容。"
"However, changes to the component fields should always be asynchronous. To visit the component fields, a task must be generated." = "不过，数据字段的更新必须是异步的。访问数据字段时，必须生成一个 task 。"
"About tasks" = "关于 task"
"Tasks are asynchronous jobs that can visit one component." = "task 是一个可以访问组件的异步过程。"
"To generate a task, call \"task(...)\" on the ref-counted token. In this way, the template will always be updated after the task ends." = "可以通过在组件的引用计数标识上调用 task(...) 来生成一个 task 。模板内容必然在这个 task 结束时更新。"
"Sometimes it is needed to read fields but not update them. To avoid the template update overhead, it is able to generate a read-or-write task." = "有时只需要读取数据字段而并不一定会改变它，此时可以生成一个“读或写” task 来避免模板更新的开销。"
"Because tasks are asynchronous, references cannot move across tasks. Thus &self is not usable in tasks. The ref-counted token can be cloned and move across tasks." = "因为 task 是异步的，引用不能穿越 task 使用。所以 &self 并不能在 task 中使用。但组件的引用计数标识可以穿越 task 。"
"this function is executed after the component creation" = "这个函数必然在组件创建后执行"
"acquire a ref-counted token of the component" = "获得这个组件的“引用计数标识”"
"generate a task" = "生成一个 task"
"the template will be updated after the task ends" = "模板会在 task 结束时更新"
"the template will be not be updated" = "模板不会被更新"
"unless need_update is called" = "除非 need_update 被调用"
"Template Updates" = "模板更新"
"Event bindings" = "事件绑定"
"It is able to bind an event listener function to DOM events." = "可以在 DOM 事件上绑定监听器。"
"Custom event arguments" = "自定义事件参数"
"When binding listeners, extra arguments can be added." = "绑定监听器时，可以添加额外的参数。"
"Only references can be used as arguments (and the data type should implement `Clone` or `ToOwned` trait)." = "只有引用可以作为参数（且数据类型必须实现有 Clone 或 ToOwned ）"
"Tap events" = "tap 事件"
"Maomi provides tap events as a combination of mouse events and touch events." = "maomi 提供了 tap 事件作为 mouse 事件和 touch 事件的结合。"
"Long tap events are also supported." = "也可以使用 long tap 事件。"
"avoid further tap event" = "阻止对应 tap 事件的生成"
"Events" = "事件"
"Define style classes" = "定义样式类"
"Maomi supports a limited form of CSS." = "maomi 支持一种受限的 CSS 写法。"
"In most cases, styles should be specified through classes." = "多数情况下，样式需要通过 class 来指定。"
"Like common rust structs, classes can be public and used by multiple components." = "类似于普通的 rust struct ， class 可以是公开的、可以被多个组件使用。"
"The class name is in the same namespace of the rust structs and enums." = "class 名与其他 rust struct 和 enum 位于同一个命名空间中。"
"Do not use element tag name as class names, otherwise the element tag name cannot be used." = "不要让节点名与 class 名相同，否则就无法使用。"
"Property syntax" = "样式属性语法"
"The stylesheet syntax is different from standard CSS." = "样式表语法与标准 CSS 有差异。"
"The basic property syntax is \"xxx = xxx;\", and the CSS words should be connected with \"_\"." = "样式属性语法形如 xxx = xxx; 且 CSS 标识符需要改用 _ 来连接。"
"Numbers with units should be written as follows:" = "带有单位的数据必须这样写："
"Colors in \"#xxx\" forms should be written as follows:" = "#xxx 这样的颜色值必须这样写："
"Debug the CSS output" = "调试生成的 CSS"
"When not sure about the CSS output, add a \"#[error_css_output]\" before the class and the generated CSS will output as an error message." = "如果不清楚生成的 CSS 究竟是什么样的，在 class 前添加一个 #[error_css_output] 可以将生成的 CSS 作为编译错误输出出来。"
"Hashed class names" = "哈希后的 class 名"
"The class names are properly hashed. It is totally OK to use the same class name in different modules." = "class 名最终会被哈希。所以完全可以在不同模块中使用相同的 class 名。"
"It is OK to specified the hashed name." = "也可以手工指定哈希后的名字。"
"Generated CSS output" = "生成的 CSS 输出"
"Maomi will generate a static CSS file for each crate." = "maomi 会为每个 crate 生成一个 CSS 输出文件。"
"To get the output CSS file, specify the output path in Cargo.toml." = "在 Cargo.toml 中指定 CSS 输出目录路径，才能得到这个 CSS 输出文件。"
"If \"css-out-mode\" is configured to \"debug\", the generated CSS will be easier to read." = "如果 css-out-mode 被设为 debug ，生成的 CSS 会更易读。"
"The CSS output is in the specified \"css-out-dir\". Generated file name is \"[CRATE_NAME].css\". Use it in HTML head:" = "CSS 输出目录应通过 css-out-dir 指定。生成的文件名是 [CRATE_名].css 。在 HTML head 中使用它："
"This two options can be override by environment variables \"MAOMI_CSS_OUT_DIR\" and \"MAOMI_CSS_OUT_MODE\"." = "这两个选项可以分别被 MAOMI_CSS_OUT_DIR 和 MAOMI_CSS_OUT_MODE 环境变量覆盖。"
"error: do not use \"div\" as class name" = "错误：不要用 div 作为 class 名"
"use \"=\" instead of \":\", and \";\" is always required" = "使用 = 代替 : ，且 ; 不可省略"
"use \"_\" instead of \"-\"" = "使用 _ 代替 -"
"this generates \"font-size: 1.5em;\"" = "生成 font-size: 1.5em;"
"this generates \"padding: 1px 0.1rem;\"" = "生成 padding: 1px 0.1rem;"
"this generates \"background-color: #00d2ff;\"" = "生成 background-color: #00d2ff;"
"Style Classes" = "样式类"
"Media Queries" = "媒体查询"
"Unlike standard CSS, media queries should be inside classes." = "与标准 CSS 不同，媒体查询需要写在 class 里面。"
"Feature detection with \"@supports\" likewise." = "使用 @support 进行特性检测也是类似的。"
"Pseudo classes" = "伪类"
"Pseudo classes should also be inside classes." = "伪类也要写在 class 里面。"
"Conditional Styles" = "条件样式"
"Constant value" = "常量"
"It is able to define constants in stylesheets." = "可以在样式表中使用常量。"
"The constant can be any CSS token, but should only be a single token." = "常量可以是任何 CSS 值，但是只能是单一值。"
"Keyframes definition" = "定义 keyframes"
"Keyframes can be declared as a special type of constants." = "keyframes 是一种特殊的常量类型。"
"cannot be multiple tokens" = "不能是多个值"
"Style Constants" = "样式常量"
"Functions with arguments" = "函数与函数参数"
"To reuse similar properties in different classes, functions can be used." = "在多个 class 间复用类似的样式属性时，可以使用函数。"
"Functions can take arguments, but the arguments can only be numbers (as \"f32\") or strings (as \"&str\")." = "函数可以带有参数，但参数只能是数值类型 f32 或者字符串类型 &str 。"
"Number arguments can be used in unit-values." = "数值参数可以在带单位的值中使用。"
"String arguments can be used in colors." = "字符串参数可以用于颜色值。"
"Dynamic Styling" = "动态样式"
"Besides classes, a special kind of functions can also be used in templates." = "除了 class ，一种特殊的函数也可以用于指定样式。"
"This kind of functions should contain exactly one argument, and declared with \"style\" instead of \"fn\"." = "这种特殊的函数接受一个参数，并使用 style 定义（而不是 fn ）。"
"This can be used when some property values should be dynamically calculated." = "它可以用于属性值需要被动态计算得出的时候。"
"Style Functions" = "样式函数"
"Global stylesheet usage" = "全局样式表用法"
"Some constants may be used in several stylesheets in the whole crate. It is able to write them in a global stylesheet." = "一些常量可能被用在多个样式表中。它们可以被写在全局样式表里。"
"The default global stylesheet is located at \"src/lib.mcss\". This path can be changed by \"stylesheet-mod-root\" in Cargo.toml." = "默认的全局样式表位于 src/lib.mcss ，这个路径可以在 Cargo.toml 中的 stylesheet-mod-root 中配置。"
"Constants can be declared inside this file." = "常量可以定义在这个文件中。"
"Stylesheets can use the global constants with a \"use\" statement." = "样式表可以通过 use 语句来引入全局常量。"
"Normal functions (not dynamic style functions) can also be declared." = "普通函数（不包括用 style 定义的函数）也可以在这里定义。"
"Then in stylesheets:" = "然后，在样式表中："
"Submodules in global stylesheets" = "全局样式表的子模块"
"If the global stylesheet is large, the \"mod\" statement can be used to split it into several files." = "如果全局样式表很大，可以用 mod 语句来将它拆成多个文件。"
"In \"src/my_sub.mcss\":" = "在 src/my_sub.mcss 中："
"Global Stylesheets" = "全局样式表"
"Using component in component" = "在组件中使用组件"
"Components in maomi are low-cost abstractions. Some web frameworks have a significant overhead with components, but maomi only has a little. Sometimes components can help improve performance." = "maomi 的组件是低开销抽象。一些其他 web 框架中的组件是高开销的，但 maomi 只有一点点开销。有时，使用组件还可以提升性能。"
"Like DOM elements, a component can be used as tags." = "像 DOM 节点一样，组件可以作为标签使用。"
"Slots in components" = "组件的 slot"
"The component can put a \"<slot />\" tag in the template. It will be replaced with the child nodes in its users." = "组件可以在模板中放置 <slot /> 标签。它会被组件使用者中的子节点代替。"
"It is able to pass data in the slot with \"data\" attribute. Its users can retrieve the reference of the data with \"slot:xxx\" attributes." = "也可以通过 slot 传递数据。组件使用者可以通过 slot:xxx 来获得这些数据。"
"Besides it, the slot data type should be specified with the \"SlotData\" attribute argument." = "同时， slot 的数据类型需要在 SlotData 组件属性中定义。"
"Using Components" = "使用组件"
"Using events in components" = "在组件中使用事件"
"Components can trigger events to its users." = "组件可以向组件使用者发送事件。"
"An event can contain a piece of data \"T\", wrapped as \"Event<T>\". The event data should be provided when triggering it." = "事件可以包含数据类型 T ，包裹为 Event<T> 。具体数据在事件触发时提供。"
"Note that the event fields should be properly \"pub\" so that it can be assigned from templates in other rust modules." = "注意事件字段需要 pub 来使得其他 rust 模块的模板可以访问到它。"
"Component Events" = "组件事件"
"Using properties in components" = "使用组件属性"
"Components can contain several fields which are assignable through template attributes." = "组件可以包含若干能够在模板上被赋值的字段。"
"The properties should be wrapped with \"Prop\". The \"Prop\" type implements \"Deref\" so it can be dereferenced to the contained type." = "属性需要被 Prop 包裹。 Prop 类型实现有 Deref ，它可以被解引用到它内含的类型。"
"Note that the property fields should be properly \"pub\" so that it can be assigned from templates in other rust modules." = "注意属性字段需要 pub 来使得其他 rust 模块的模板可以访问到它。"
"Two-way properties" = "双向属性"
"Common properties are one-way: the component receives the value from its user." = "普通的属性是单向的：组件从组件的使用者处收到数据。"
"Sometimes it is required to be two-way, e.g. synchronize input values between components." = "有时希望它是双向的，例如需要将 input 值传递给使用者的时候。"
"In these cases, \"BindingProp\" and \"BindingValue\" can be used. However, the changes of two-way values do not automatically triggering the template update. A task should be manually generated if the template update is required." = "这种情况时，可以使用 BindingProp 和 BindingValue 。但双向数据更新并不会自动触发模板更新。如果需要更新模板，就需要手工生成一个 task 来更新。"
"Note that \"BindingProp\" and \"BindingValue\" do not implement \"Deref\" - use explicit getter functions to retrieve the value." = "注意 BindingProp 和 BindingValue 未实现 Deref ，需要用 get 函数来获取其中的值。"
"Properties" = "属性"
"How server side rendering works" = "服务器端渲染是如何工作的"
"Normally, maomi generates HTML elements in browsers. At startup, it takes an empty DOM node, a.k.a. a mount-point, and then repeatedly insert or modify other nodes." = "普通情况下， maomi 在浏览器中生成 HTML 节点。在初始化时，它从一个空的 DOM 节点（即挂载点）开始，不断向其中插入和修改子孙节点。"
"The server side rendering can generate static HTML segments in the server. The HTML segment can be inserted into the mount-point before startup. Then maomi will reuse the generated HTML nodes at startup." = "服务器端渲染可以在服务器上生成 HTML 片段。这个 HTML 片段可以在初始化前被插入到挂载点中，然后 maomi 会复用这些 HTML 节点。"
"This allows static contents embed in HTML directly, and be understood by search engines better." = "这使得静态内容可以直接内嵌到 HTML 中，更利于搜索引擎理解。"
"Because maomi is in rust, the component code can be compiled to native binary which can be used to generate HTML segments. It means the components are compiled twice: one is to the native binary which is used to generate the static HTML, the other is to the WebAssembly binary which is used in browser runtime." = "因为 maomi 是 rust 编写的，组件代码可以被编译为原生代码、直接用于生成 HTML 。这意味着组件会被编译两次：一次是编译为原生代码，另一次是编译为在浏览器中运行的 WebAssembly 代码。"
"To enable server side rendering, some features need to be specified in Cargo.toml. The \"prerendering\" feature is to enable the server side support, and the \"prerendering-apply\" feature is to enable the reuse of the server side generated nodes." = "使用服务器端渲染前，需要在 Cargo.toml 中指定额外的 feature 。激活 prerendering 可以启用服务器端支持，激活 prerendering-apply 则可以在客户端复用服务器端生成的 HTML 节点。"
"Note that these features slightly increase the runtime overhead. Do not enable them if server side rendering is not needed." = "请注意激活这些 feature 会带来一点点运行时开销。如果不用服务器端渲染就不要激活它们。"
"Prerenderable Components" = "预渲染组件"
"To be rendered in server side, the component must implement \"PrerenderableComponent\". This trait has two associated types and two functions." = "为了能在服务器端渲染，组件必须实现 PrerenderableComponent 。这个 trait 有两个关联类型和两个关联函数。"
"The \"QueryData\" type refers to the query, e.g. the URL params, the POST data, or some other related data. For static contents, it can simply be \"()\"." = "QueryData 代表请求参数的类型，比如 URL 参数、 POST 数据或者其他相关数据。对于静态内容，可以只是一个空类型 () 。"
"The \"PrerenderingData\" type is converted from the \"QueryData\", containing some useful parts of the query for the component startup. It should be serializable and transferable from server side to the client side." = "PrerenderingData 代表预渲染数据的类型。预渲染数据由 QueryData 转化得到，包含 QueryData 中有用的信息数据。它应当能被序列化并从服务器端传到客户端。"
"When doing server side rendering, firstly, the \"prerendering_data\" function is called in server side to convert \"QueryData\" to \"PrerenderingData\". (It may also be called in client side when doing client side rendering.)" = "服务器端渲染时，首先， prerendering_data 函数被调用，用于将 QueryData 转换为 PrerenderingData 。（当进行客户端渲染时，它也可能在客户端被调用。）"
"Secondly, the component starts in the server side, and the \"apply_prerendering_data\" is called. This function can modify component fields according to the \"PrerenderingData\". The HTML segment can be generated when the component created." = "第二，组件在服务器端被创建， apply_prerendering_data 被调用。这个函数根据 PrerenderingData 来更新组件数据字段。组件创建完成后， HTML 片段就可以生成了。"
"Thirdly, the generated HTML should be embed into the mount-point, and the \"PrerenderingData\" should also be transferred to the client side." = "第三，生成的 HTML 需要被嵌入到挂载点中， PrerenderingData 也要被传递到客户端。"
"Fourthly, the component starts in the client side, and the \"apply_prerendering_data\" is also called. This function must do the same thing as it did in the server side. Thus this component can reuse the generated HTML nodes." = "第四，组件在客户端启动， apply_prerendering_data 同样被调用。这个函数的执行必须与在服务器端的执行逻辑相同。这样组件就可以复用服务器端生成的 HTML 节点了。"
"Generate HTML in server side" = "在服务器端生成 HTML"
"To generate HTML in server side, a special kind of backend context is used." = "在服务器端生成 HTML 需要用到特殊的 backend 环境"
"Reuse the generated HTML in client side" = "在客户端复用生成的 HTML 节点"
"To reuse the generated HTML, the backend context should be initialized in with \"PrerenderingData\"." = "为了复用生成好的 HTML ， backend 环境需要使用 PrerenderingData 来初始化。"
"generate the `PrerenderingData`" = "生成 PrerenderingData"
"serialize the `PrerenderingData` to transfer to the client side" = "序列化 PrerenderingData 并传递给客户端"
"initialize a backend context for HTML generation" = "初始化一个 backend 环境用于 HTML 生成"
"generate HTML segment" = "生成 HTML 片段"
"returns the HTML and the `PrerenderingData`" = "返回 HTML 片段和 PrerenderingData"
"the HTML should finally be placed in the HTML <body />" = "生成好的 HTML 需要最终放置在 HTML <body /> 内"
"the `PrerenderingData` can be base64 embed to HTML or transfer in other forms" = "PrerenderingData 可以被 base64 编码后放入 HTML 中，或者以其他形式传输到客户端"
"deserialize the `PrerenderingData`" = "反序列化 PrerenderingData"
"construct the `PrerenderingData`" = "构建 PrerenderingData"
"initialize a backend context for reuse generated HTML" = "初始化 backend 环境，用于复用生成好的 HTML"
"create the mount point" = "创建挂载点"
"Server Side Rendering" = "服务器端渲染"
"Enable i18n support" = "激活 i18n 国际化支持"
"Maomi can generate different binaries for different languages, a.k.a. the i18n support." = "maomi 可以为不同语言生成不同的编译结果，即国际化支持。"
"By default, i18n support is disable. To enable it, specify the locale in \"MAOMI_I18N_LOCALE\" environment variable while compilation." = "默认情况下，国际化支持未启用。指定 MAOMI_I18N_LOCALE 环境变量就可以启用它。"
"When this environment variable often changes, it is recommended to add this line to build.rs:" = "如果这个环境变量经常变化，建议在 build.rs 中指定："
"Translation files" = "翻译文件"
"When i18n support enabled, maomi requires every text node in the template to be translated." = "启用国际化支持后， maomi 要求所有文本节点内容必须被翻译过。"
"Every string without translation will be marked a compilation error." = "未被翻译的文本字符串都将被标记为编译错误。"
"To translate this string, create a \"i18n/[LOCALE].toml\" file. Use \"i18n/zh_CN.toml\" as an example:" = "翻译字符串时，先创建一个 i18n/[LOCALE].toml 文件。以 i18n/zh_CN.toml 为例："
"The string will be replaced according to this file when compiling the \"MAOMI_I18N_LOCALE=zh_CN\" version." = "当编译 MAOMI_I18N_LOCALE=zh_CN 版本时，字符串将依据这个文件的内容来替换。"
"Dynamic string translation" = "动态字符串翻译"
"If the text node is an expression, the value must be a \"LocaleString\" or \"LocaleStaticStr\". Normal strings are not accepted." = "如果文本是一个表达式，它的值类型必须是 LocaleString 或者 LocaleStaticStr ，不能是普通字符串。"
"If the string is static and can be translated through translation files, the `i18n!` macro can be used to translate it." = "如果字符串是静态的、可以被翻译文件翻译，则可以通过 i18n! 宏来翻译它。"
"If the string is dynamic content or does not need to be translated, mark it as translated manually." = "如果字符串内容是动态的、不需要被翻译，可以把它直接标记为已翻译的。"
"Translation groups" = "翻译组"
"By default, the \"[translation]\" group in translation files are used. It is able to use other groups." = "[translation] 是翻译文件中被默认使用的组。也可以改用其他组。"
"Then in the translation file:" = "在翻译文件中："
"For dynamic string translation, use \"i18n_group!\" to get the group." = "对于动态字符串翻译，可以使用 i18n_group! 来获得这个组。"
"Format tools for translation files" = "翻译文件的格式化工具"
"The \"maomi-tools\" crate provides a tool \"maomi-i18n-format\" to collect untranslated strings and format the translation files." = "maomi-tools crate 提供了一个 maomi-i18n-format 工具，用来搜集所有未翻译的字符串并格式化翻译文件。"
"Collect the metadata with \"MAOMI_I18N_LOCALE\" and \"MAOMI_I18N_FORMAT_METADATA\" environment variable." = "设置 MAOMI_I18N_LOCALE 和 MAOMI_I18N_FORMAT_METADATA 来搜集翻译所需的信息。"
"Then do the format:" = "然后格式化："
"I18n Support" = "i18n 国际化支持"
"About execution speed" = "关于执行速度"
"Maomi is greatly optimized on execution speed. In most cases, there is no need to worry about it." = "maomi 为执行速度进行了大量优化，多数情况下无需操心。"
"On the other hand, most high-level code does not need to be so fast. Don't be afraid to write simple code that is a little slower." = "从另一方面来说，大多数高层逻辑代码并不需要很高性能。不要害怕写了些简单但有点慢的代码。"
"If there is a need of profiling, note that the release builds are much faster then debug builds (like most rust programs do)." = "如果需要分析运行性能，请注意 release 构建结果会比 debug 的快得多（如同大多数 rust 程序）。"
"About code size" = "关于代码尺寸"
"In most cases, WebAssembly binary is bigger than JavaScript code, but it generally has a better compression rate. Do not forget to turn on HTTP compression on the generated binary." = "多数情况下 WebAssembly 代码会比 JavaScript 代码更大，但总体上说也会有更好的压缩率。别忘了在传输时启用 HTTP 压缩。"
"Besides that, some code generation options have great helps to reduce the generated WebAssembly binary size. It is recommended to use the following options in Cargo.toml." = "同时，一些代码生成选项可以大大降低生成的代码尺寸。建议在 Cargo.toml 中添加如下配置。"
"Runtime Performance Tips" = "运行时性能建议"
"About compilation time" = "编译性能"
"Maomi requires a lot of compile-time optimizations, so the compilation time might be really long in old machines." = "maomi 需要进行大量编译期优化，所以编译时间在旧的机器上会比较长。"
"To improve the compilation speed, the best way is to split components into several small crates, since rust compilation is crate-by-crate. If a crate code is not changed, it will not be re-compiled." = "提升编译性能的最佳方法是将组件拆分到更小的 crate 中，因为 rust 编译时以 crate 为单位的。如果 crate 代码没变，就不会被重新编译。"
"Another important tip is to avoid server side rendering compilation while debugging component logic. Since when server side rendering requires native binary for each components, this doubles the compilation time." = "另一个重要的建议是在调试组件逻辑时不启用服务器端渲染。因为服务器端渲染需要为各个组件多编译一份原生代码，将编译时间延长一倍。"
"In general, smaller components bring more code re-using and compile faster. In maomi, components are near zero-cost abstractions which has very low runtime overhead." = "总体上说，更小的组件更容易被复用、编译更快。在 maomi 中，组件近乎于零开销抽象、只有很低的运行时开销。"
"About working with IDE" = "关于在 IDE 中编写代码"
"When editing code in IDE with rust-analyzer, large code may slow down rust-analyzer, bringing bad coding experience." = "在安装有 rust-analyzer 的 IDE 编写代码时，大代码通常会减慢 rust-analyzer ，带来较差的编程体验。"
"It is able to tell maomi to optimize for rust-analyzer. When working with rust-analyzer, maomi can try to generate faster results. The results is not runnable but fast in cargo check." = "可以让 maomi 激活针对 rust-analyzer 的优化。当在 rust-analyzer 中编译时， maomi 可以尝试更快速的结果生成。这样的结果并不能运行但 cargo check 更快。"
"To enable this feature, set environment variable MAOMI_RUST_ANALYZER=on to rust-analyzer. Use Visual Studio Code as the example, this environment variable can be set in \"rust-analyzer.cargo.extraEnv\" settings." = "激活这个特性时需要设置环境变量 MAOMI_RUST_ANALYZER=on 。以 Visual Studio Code 为例，环境变量可以在 rust-analyzer.cargo.extraEnv 中配置。"
"Compilation Performance Tips" = "编译期性能建议"
"Basics" = "基础入门"
"Template Semantics" = "模板语法"
"Stylesheets" = "样式表"
"Components" = "组件"
"Advanced Features" = "高级特性"
"Performance Tips" = "性能建议"
